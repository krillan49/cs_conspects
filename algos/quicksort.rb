puts '                                  Алгоритм сортировки Quicksort'

# Быстрая сортировка — один из наиболее широко используемых алгоритмов сортировки. Он быстрый и также требует минимального дополнительного хранилища, поскольку он просто меняет элементы местами. На практике, как только подсписки становятся короткими, можно использовать более простые алгоритмы, такие как сортировка вставкой. Библиотечная функция сортировки для многих языков программирования является версией быстрой сортировки.


# Для примера рассмотрим сортировку массива целых чисел в порядке возрастания

# Схема алгоритма:

# Быстрая сортировка начинается с выбора элемента в списке, называемого опорным элементом. Опорный элемент в нашей реализации всегда является первым элементом. Алгоритм разбивает список на два подсписка, элементы меньше и больше опорного элемента, и помещает опорный элемент между ними. Он повторяет этот процесс для двух подсписков, пока весь список не будет отсортирован.

# Разделение выполняется с помощью индексов i и j для поиска элементов, которые следует поменять местами.
# i - начинается с позиции справа от опорного элемента и перемещается вправо.
# j - начинается с конца списка и перемещается влево.
# Если i находит элемент больше опорного элемента и j находит элемент меньше опорного элемента, эти элементы меняются местами. Элементы, которые равны опорному элементу, игнорируются. Когда i и j пересекаются, алгоритм завершает процесс разделения, меняя опорный элемент на элемент в позиции j.

# Существуют и другие реализации быстрой сортировки!

# Пример:
[30, 50, 5, 30, 51, 10, 20, 99, 18, 30, 100, 33]

# Этап 1 — Разбиение списка:
# =================================

# Опорная точка — 30. i начинается с 50, этот элемент больше опорной точки, соответсвенно i дальше не меняется. j начинается с 33, этот элемент, меньше опорной точки, потому, j уменьшается, пока не достигает 18.
[30, 50, 5, 30, 51, 10, 20, 99, 18, 30, 100, 33]
#    i                          j
# Меняем местами 18 и 50:
[30, 18, 5, 30, 51, 10, 20, 99, 50, 30, 100, 33]
# i и j проверяют и двигаются дальше. Следующий элемент, больший, чем опорный элемент(30), на который переходит i это 51. Следующий элемент, меньший, чем опорный элемент, на который переходит j это 20. После их перестановки будет:
[30, 18, 5, 30, 20, 10, 51, 99, 50, 30, 100, 33]
# Этот процесс продолжается до тех пор, пока i и j не пересекутся, тоесть станет i >= j
[30, 18, 5, 30, 20, 10, 51, 99, 50, 30, 100, 33]
#                   j   i
# Далее алгоритм завершает процесс разбиения, меняя опорную точку(30) с элементом в позиции j. В данном случае это 10
[10, 18, 5, 30, 20, 30, 51, 99, 50, 30, 100, 33]

# Что было достигнуто? Все элементы слева от опорного элемента меньше или равны ему, а все элементы справа от опорного элемента больше или равны ему. Опорный элемент 30 находится в правильной отсортированной позиции.
# Мы разделили список на два подсписка с опорным элементом между ними. Теперь мы повторяем процесс для двух подсписков
[10, 18, 5, 30, 20]
# и
[51, 99, 50, 30, 100, 33]
# В некоторых случаях один из подсписков может содержать только один элемент, если i и j встречаются либо в начале, либо в конце списка

# Этап 2 — Разбиение первого подсписка
# =================================

# Рассмотрим первый подсписок
[10, 18, 5, 30, 20]
# Установите опорный элемент на первый элемент 10. i и j поменяйте местами больший 18 с меньшим 5.
[10, 5, 18, 30, 20]
# Они больше не меняются местами, прежде чем пересекутся. Затем мы меняем опорный элемент с элементом в позиции j
[5, 10, 18, 30, 20]
# Мы разделились на
[18, 30, 20]
# и
[5]
# с опорным элементом 10 между ними.

# Этап 3 — Продолжайте разбиение, пока не будет отсортирован первый подсписок.
# ================================

# Повторите процесс для этих двух подсписков. Очевидно, что список из одного элемента [5] отсортирован.
# Второй подсписок
[18, 30, 20]
# требует двух шагов. Сначала 18 выбирается в качестве опорного элемента. Поскольку это минимальный элемент в подсписке, j он перемещается на самый верх списка, в то время как i не перемещается, и никаких обменов не происходит. Поскольку j оказывается в позиции 0, обмен опорного элемента с элементом в позиции j не имеет никакого эффекта. Опорный элемент 18 уже находится в правильной позиции, и генерируется подподсписок [30, 20]. Теперь 30 выбирается в качестве опорного элемента и меняется местами с 20. Исходный первый подсписок был отсортирован.
[10, 18, 5, 30, 20]

# Этап 4 — Разбиение второго подсписка
# ====================================

# Повторите процесс для второго подсписка
[51, 99, 50, 30, 100, 33]
# Опорный элемент — первый элемент 51. i и j поменяйте местами больший 99 с меньшим 33, но ничего больше. Затем опорный элемент меняется местами с элементом в позиции j, 30. Это разделяет
[51, 99, 50, 30, 100, 33]
# на подсписки
[30, 33, 50]
# и
[100, 99]
# опорный элемент 51 между ними.

# Этап 5 — Продолжайте разбиение, пока не будет отсортирован второй подсписок.
# ====================================

# Повторите процесс для этих двух подсписков.
[30, 33, 50] # уже отсортирован.
# После замены 99 на 100 второй подсписок отсортирован, и, следовательно, весь список также.

# Начальный массив менялся такими шагами:
[30, 50, 5, 30, 51, 10, 20, 99, 18, 30, 100, 33]
solution5_with_explanation = [
  [[30, 18, 5, 30, 51, 10, 20, 99, 50, 30, 100, 33], 'Swapped 50 in position 1 with 18 in position 8'],
  [[30, 18, 5, 30, 20, 10, 51, 99, 50, 30, 100, 33], 'Swapped 51 in position 4 with 20 in position 6'],
  [[10, 18, 5, 30, 20, 30, 51, 99, 50, 30, 100, 33], 'Swapped pivot 30 in position 0 with 10 in position 5'],
  [[10, 5, 18, 30, 20, 30, 51, 99, 50, 30, 100, 33], 'Swapped 18 in position 1 with 5 in position 2'],
  [[5, 10, 18, 30, 20, 30, 51, 99, 50, 30, 100, 33], 'Swapped pivot 10 in position 0 with 5 in position 1'],
  [[5, 10, 18, 20, 30, 30, 51, 99, 50, 30, 100, 33], 'Swapped pivot 30 in position 3 with 20 in position 4'],
  [[5, 10, 18, 20, 30, 30, 51, 33, 50, 30, 100, 99], 'Swapped 99 in position 7 with 33 in position 11'],
  [[5, 10, 18, 20, 30, 30, 30, 33, 50, 51, 100, 99], 'Swapped pivot 51 in position 6 with 30 in position 9'],
  [[5, 10, 18, 20, 30, 30, 30, 33, 50, 51, 99, 100], 'Swapped pivot 100 in position 10 with 99 in position 11']
]



puts '                                        Варианты реализации'

# https://www.codewars.com/kata/6641778ddab67c48a794387d/solutions/ruby     - другие варианты на Руби

# Вариант с рекурсивной передачей частей массива
def quicksort(data)
  # Проходим индексами по массиву
  i, j = 0, data.length-1
  while i < j
    if data[i] > data[0] && data[j] < data[0]
      data[i], data[j] = data[j], data[i]
    end
    i += 1 if data[i] <= data[0]
    j -= 1 if data[j] >= data[0]
  end
  # меняем опорный элемент на элемент в j, если опорный меньше
  i, j = 0, data.length-1
  while i < j
    if data[j] < data[0]
      data[i], data[j] = data[j], data[i]
      break
    end
    j -= 1 if data[j] >= data[0]
  end
  # подмассив до старого опорного элемента
  first_part = if data[0...j] != nil && data[0...j].length > 1
    quicksort(data[0...j])
  elsif data[0...j] != nil && data[0...j].length == 1
    data[0...j]
  else
    []
  end
  # старый опорный элемент
  mid_part = [data[j]]
  # подмассив после старого опорного элемента
  last_part = if data[j+1..] != nil && data[j+1..].length > 1
    quicksort(data[j+1..])
  elsif data[j+1..] != nil && data[j+1..].length == 1
    data[j+1..]
  else
    []
  end
  first_part + mid_part + last_part
end

p quicksort([30, 50, 5, 30, 51, 10, 20, 99, 18, 30, 100, 33])














#
